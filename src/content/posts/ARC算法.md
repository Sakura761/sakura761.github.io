---
title: ARC算法
published: 2025-12-30
slug: arc-algorithm
description: ""
tags: []
category: 算法
draft: false
---

#### 1. 为什么我们需要 ARC？（背景）

在 ARC 出现之前，主要有两种主流算法：

- **LRU (Recency - 最近性)**:
  - **优点**: 简单，能快速适应最新的访问模式。
  - **缺点**: **抗扫描能力差**。如果一次性扫描大量只访问一次的数据（比如全表扫描），会把缓存中高频使用的热点数据全部挤出去（缓存污染）。
- **LFU (Frequency - 频率性)**:
  - **优点**: 稳定，能长期保留高频热点数据。
  - **缺点**: **适应性差**。如果一个数据以前访问了很多次但现在不再使用了，它依然会长期霸占缓存（“旧富翁”问题）。而且对新突发的热点反应慢。

**ARC 的创新点**：它不固定使用 LRU 或 LFU，而是维护两个列表（一个侧重最近性，一个侧重频率），并根据实际命中情况，**动态调整**这两个列表的大小比例。

#### 2. ARC 的核心数据结构

ARC 将整个缓存空间（容量为 $c$）和历史记录（Ghost 列表）分成了四个部分。我们可以想象成两个主要的双向链表：$L1$ 和 $L2$。

##### 2.1 四个列表（List）

1.  **T1 (Top 1 - 最近访问过 1 次)**:
    - 存放**最近**被访问过，且只被访问了 **1次** 的页面。
    - 类似于 LRU 列表。
    - 存放实际数据（在内存中）。
2.  **B1 (Bottom 1 - T1 的幽灵列表)**:
    - 从 T1 中被淘汰出来的页面元数据（只存 Key，不存 Value）。
    - 代表“最近访问过 1 次，但因缓存满了被淘汰”的历史。
3.  **T2 (Top 2 - 最近访问过 $\\ge$ 2 次)**:
    - 存放被访问了 **至少 2 次** 的页面。
    - 类似于 LFU 列表。
    - 存放实际数据（在内存中）。
4.  **B2 (Bottom 2 - T2 的幽灵列表)**:
    - 从 T2 中被淘汰出来的页面元数据。
    - 代表“曾经是高频数据，但因缓存满了被淘汰”的历史。

##### 2.2 容量关系

- **实际缓存容量 $c$**: $|T1| + |T2| \\le c$。
- **历史记录**: ARC 会记录两倍于缓存大小的信息，即 $|T1| + |B1| + |T2| + |B2| \\approx 2c$。

##### 2.3 核心参数 $p$ (Target)

ARC 维护了一个可调参数 **$p$**，代表 **T1 列表的目标大小**。

- 如果 $p$ 增大：意味着系统认为“最近性”更重要，给 T1 分配更多空间。
- 如果 $p$ 减小：意味着系统认为“频率”更重要，给 T2 分配更多空间（挤压 T1）。

#### 3. 算法工作流程（详细逻辑）

当一个页面请求到来时，可能发生以下几种情况：

##### 情况 A：缓存命中 (Cache Hit)

数据已经在内存中（在 T1 或 T2 中）。

1.  **在 T1 中命中**:
    - 说明该数据被访问了第 2 次，它晋升了。
    - **操作**: 将其从 T1 移到 **T2 的 前端（也就是头部）** 位置。
2.  **在 T2 中命中**:
    - 说明该数据依然是热点。
    - **操作**: 将其移动到 **T2 的 前端（也就是头部）** 位置。

##### 情况 B：缓存未命中，但在幽灵列表中命中 (Ghost Hit / Phantom Hit)

这是 ARC **自适应（Adaptive）** 的核心所在。这表示“如果我们的缓存稍微大一点，或者策略稍微调整一下，本来是能命中的”。

1.  **在 B1 中命中 (历史说明它属于“最近性”数据)**:
    - 含义：我们刚才淘汰了一个“最近”的数据，结果它马上又被访问了。这说明 T1 太小了，导致 LRU 侧的数据被过早淘汰。
    - **自适应调整**: **增大 $p$**（增加 T1 的目标容量）。
    - **操作**: 将数据加载进缓存，放入 **T2 的 MRU**（因为它被访问了两次：一次是以前进 T1，一次是现在）。从 T1 或 T2 中置换出一个页面到对应的 Ghost 列表。

2.  **在 B2 中命中 (历史说明它属于“频率性”数据)**:
    - 含义：我们刚才淘汰了一个“高频”数据。这说明 T2 太小了。
    - **自适应调整**: **减小 $p$**（减少 T1 的容量，即增加 T2 的容量）。
    - **操作**: 将数据加载进缓存，放入 **T2 的 MRU**。从 T1 或 T2 中置换出一个页面。

##### 情况 C：完全未命中 (Cache Miss)

数据既不在 T1/T2，也不在 B1/B2。这是一个全新的数据。

- **操作**:
  1.  如果 $L1$ ($T1+B1$) 的长度达到了 $c$，需要从 B1 的尾部淘汰旧记录。
  2.  如果整个系统记录数达到了 $2c$，需要从 B2 的尾部淘汰旧记录。
  3.  执行 **Replace（替换）** 过程（腾出内存空间）：根据当前的 $p$ 值，决定是从 T1 还是 T2 的尾部淘汰数据到对应的 B1 或 B2。
  4.  将新数据放入 **T1 的 MRU** 位置。

#### 4. Replace（替换）子程序细节

当需要腾出空间来存放新页面时，ARC 依据 $p$ 来决定淘汰谁：

- 如果 $|T1| > p$：说明 T1 占用的空间超过了目标值，**淘汰 T1 的 LRU 页面**（移入 B1）。
- 如果 $|T1| < p$：说明 T1 还没达到目标，或者 T2 占用太多了，**淘汰 T2 的 LRU 页面**（移入 B2）。

#### 5. 自适应调整公式

当 **B1 命中** 时，我们增加 $p$：
$$p = p + \\delta_1$$
其中 $\\delta_1$ 通常取 1。但如果 $|B1| < |B2|$（说明最近 B2 淘汰得更多），为了加速适应，$\\delta_1$ 会变大：$\\delta_1 = |B2| / |B1|$。

当 **B2 命中** 时，我们减小 $p$：
$$p = p - \\delta_2$$
同理，如果 $|B2| < |B1|$，$\\delta_2 = |B1| / |B2|$。

#### 6. ARC 的优缺点

##### 优点

1.  **高性能**: 命中率通常优于 LRU，接近或优于精心调优的 LFU。
2.  **抗扫描 (Scan Resistant)**: 只有被访问两次的数据才能进入 T2。一次性的扫描数据只会流经 T1 然后被快速淘汰，不会污染 T2 中的高频数据。
3.  **零参数 (Parameter-free)**: 不需要管理员像配置 LRU-K 那样去手动设置 K 值或权重，完全自适应。
4.  **低开销**: 相比 LFU（需要维护复杂的堆或计数器），ARC 只需要维护几个链表，时间复杂度为 $O(1)$。

##### 缺点

1.  **复杂性**: 逻辑比 LRU 复杂，实现代码量稍大。
2.  **专利问题 (已过期)**: IBM 曾拥有 ARC 的专利，导致 Linux 内核和 PostgreSQL 等开源项目无法直接使用（PostgreSQL 采用了类似的 Clock-Pro，ZFS 使用了 ARC）。_注：该专利已于 2023 年左右过期。_

#### 总结

ARC 算法之所以强大，是因为它**不仅利用了缓存中的数据，还利用了“被淘汰的数据”**。它通过监听 B1 和 B2 的“抱怨”（Ghost Hit），实时得知当前工作负载是更偏向“最近访问”还是“高频访问”，从而动态调整 LRU 和 LFU 的配比。
